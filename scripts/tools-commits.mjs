#!/usr/bin/env node
/**
 * tools-commits.mjs
 *
 * Generiert Commit-Metadaten pro Tool und schreibt sie nach
 * `src/app/tools/tool-commits.ts`. Grundlage sind lokale Git-Logs,
 * damit `npm run tools:refresh` die Infos automatisch aktualisiert.
 */

import fs from 'node:fs';
import path from 'node:path';
import { spawnSync } from 'node:child_process';

const repoRoot = process.cwd();

const tools = [
  {
    slug: 'randomizer',
    repoUrl: 'https://github.com/DasRind/KuhLabs',
    gitCwd: '.',
    commitPaths: ['external/tools/randomizer'],
    limit: 3,
  },
];

const targetFile = path.resolve(repoRoot, 'src/app/tools/tool-commits.ts');

const data = {};
for (const tool of tools) {
  const commits = collectCommits(tool);
  data[tool.slug] = commits;
}

writeOutput(data);

function collectCommits(tool) {
  const cwd = path.resolve(repoRoot, tool.gitCwd || '.');
  const limit = tool.limit ?? 3;
  const format = '%H%x1f%cd%x1f%s%x1e';
  const baseArgs = ['log', `-n`, String(limit), '--date=short', `--pretty=format:${format}`];
  const argSets = [];
  if (Array.isArray(tool.commitPaths) && tool.commitPaths.length) {
    argSets.push([...baseArgs, '--', ...tool.commitPaths]);
  }
  argSets.push(baseArgs);

  for (const args of argSets) {
    const result = spawnSync('git', args, {
      cwd,
      encoding: 'utf8',
      stdio: ['ignore', 'pipe', 'pipe'],
    });
    if (result.status !== 0) {
      console.warn(`[tools-commits] ${tool.slug}: git ${args.join(' ')} fehlgeschlagen (${result.stderr.trim() || 'unbekannter Fehler'}).`);
      continue;
    }
    const output = result.stdout.trim();
    if (!output) {
      // Keine Treffer (z. B. Submodule noch nie upgedatet) – versuche nächste Arg-Variante.
      continue;
    }
    const records = parseGitRecords(output).map(rec => ({
      hash: rec.hash,
      date: rec.date,
      message: rec.message,
      ...(tool.repoUrl ? { url: `${tool.repoUrl}/commit/${rec.hash}` } : {}),
    }));
    if (records.length) return records;
  }

  return [];
}

function parseGitRecords(raw) {
  const records = [];
  const entries = raw.split('\u001e');
  for (const entry of entries) {
    if (!entry) continue;
    const [hash, date, message] = entry.trim().split('\u001f');
    if (!hash || !message) continue;
    records.push({ hash, date, message });
  }
  return records;
}

function writeOutput(map) {
  const header = `/* Auto-generated by scripts/tools-commits.mjs on ${new Date().toISOString()} */\n`;
  const bodyLines = [];
  bodyLines.push("import type { ToolCommit } from './tool-commit.types';");
  bodyLines.push('');
  bodyLines.push('export const TOOL_COMMITS: Record<string, ToolCommit[]> = {');
  const entries = Object.entries(map);
  for (const [slug, commits] of entries) {
    bodyLines.push(`  ${JSON.stringify(slug)}: [`);
    for (const commit of commits) {
      const fields = Object.entries(commit)
        .map(([key, value]) => `${key}: ${JSON.stringify(value)}`)
        .join(', ');
      bodyLines.push(`    { ${fields} },`);
    }
    bodyLines.push('  ],');
  }
  bodyLines.push('};');
  bodyLines.push('');
  fs.writeFileSync(targetFile, header + bodyLines.join('\n'), 'utf8');
  console.log(`[tools-commits] Aktualisiert ${path.relative(repoRoot, targetFile)}.`);
}
